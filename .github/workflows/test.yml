name: 'Run Test'

on:
  workflow_call:
    inputs:
      NODE_VERSION:
        default: '20.18.0'
        description: 'Node.js version'
        type: string
      FAIL_FAST:
        default: true
        description: 'Stop pipeline on test failure'
        required: false
        type: boolean
      COVERAGE_THRESHOLD:
        default: 80
        description: 'Minimum coverage threshold (%)'
        required: false
        type: number

jobs:
  serverless_test:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ github.head_ref }}
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ inputs.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run ESLint
        id: lint
        continue-on-error: true
        run: |
          npm run lint-ci
          if [ -f "checkstyle-eslint.xml" ]; then
            ERROR_COUNT=$(grep -c "<error" checkstyle-eslint.xml || true)
            if [ "$ERROR_COUNT" -gt 0 ]; then
              echo "LINT_STATUS=1" >> $GITHUB_ENV
              echo "Found $ERROR_COUNT lint errors"
            else
              echo "LINT_STATUS=0" >> $GITHUB_ENV
            fi
          else
            echo "LINT_STATUS=0" >> $GITHUB_ENV
          fi
      - name: Run tests
        id: tests
        continue-on-error: true
        run: |
          npm run test-ci
          TEST_STATUS=$?
          echo "TEST_STATUS=$TEST_STATUS" >> $GITHUB_ENV

      - name: Process test results
        id: process_results
        shell: bash
        run: |
          # Extract coverage from jest-junit report
          # COVERAGE=$(cat coverage/coverage-summary.json | jq -r '.total.lines.pct')
          COVERAGE=$(jq -r '.total.lines.pct' coverage/coverage-summary.json)
          echo "COVERAGE=$COVERAGE" >> $GITHUB_ENV

          # Prepare test summary
          echo "## Test Execution Results" > summary.txt
          echo "" >> summary.txt
          echo "### Overview" >> summary.txt
          echo "| Check | Status | Details |" >> summary.txt
          echo "|--------|--------|----------|" >> summary.txt
          
          # Add Lint results
          if [ "$LINT_STATUS" = "0" ]; then
            echo "| Lint | ‚úÖ | Passed |" >> summary.txt
            LINT_MESSAGE="‚úÖ Lint passed"
          else
            echo "| Lint | ‚ùå | Failed |" >> summary.txt
            LINT_MESSAGE="‚ùå Lint failed"
          fi
          
          # Add Test results
          if [ "$TEST_STATUS" = "0" ]; then
            echo "| Tests | ‚úÖ | All tests passed |" >> summary.txt
            TEST_MESSAGE="‚úÖ All tests passed"
          else
            echo "| Tests | ‚ùå | Tests failed |" >> summary.txt
            TEST_MESSAGE="‚ùå Some tests failed"
          fi
          
          # Add Coverage results
          if (( $(echo "$COVERAGE >= ${{ inputs.COVERAGE_THRESHOLD }}" | bc -l) )); then
            echo "| Coverage | ‚úÖ | ${COVERAGE}% |" >> summary.txt
            COVERAGE_MESSAGE="‚úÖ Coverage meets threshold"
          else
            echo "| Coverage | ‚ö†Ô∏è | ${COVERAGE}% |" >> summary.txt
            COVERAGE_MESSAGE="‚ö†Ô∏è Coverage below threshold"
          fi

          # Create test results JSON
          cat << EOF > .github_testresults
          {
            "test": {
              "test_status": "$([ "$TEST_STATUS" = "0" ] && echo "success" || echo "failed")",
              "lint_status": "$([ "$LINT_STATUS" = "0" ] && echo "success" || echo "failed")",
              "coverage": $COVERAGE,
              "coverage_status": "$([ "$COVERAGE" -ge "${{ inputs.COVERAGE_THRESHOLD }}" ] && echo "success" || echo "failed")",
              "coverage_threshold": ${{ inputs.COVERAGE_THRESHOLD }},
              "test_message": "$TEST_MESSAGE",
              "lint_message": "$LINT_MESSAGE",
              "coverage_message": "$COVERAGE_MESSAGE",
              "timestamp": "$(date -u +"%Y-%m-%dT%H:%M:%SZ")",
              "run_id": "${{ github.run_id }}",
              "run_url": "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
            }
          }
          EOF

      - name: Check for test results and comment PR
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            
            let results;
            try {
              results = JSON.parse(fs.readFileSync('.github_testresults', 'utf8'));
            } catch (error) {
              console.log('Error reading test results:', error);
              return;
            }
            
            let body = '# üîç Test Results\n\n';
            body += fs.readFileSync('summary.txt', 'utf8') + '\n\n';
            const MAX_LINES = 50;

            if (fs.existsSync('checkstyle-eslint.xml')) {
              const eslintOutput = fs.readFileSync('checkstyle-eslint.xml', 'utf8');
              const lintErrors = eslintOutput.match(/<error.*?\/>/g) || [];
              const fileMatch = eslintOutput.match(/name="([^"]+)"/g) || [];
              const files = fileMatch.map(f => f.match(/name="([^"]+)"/)[1]);

              const formattedErrors = lintErrors.map((error, index) => {
                const line = error.match(/line="(\d+)"/)[1];
                const column = error.match(/column="(\d+)"/)[1];
                const severity = error.match(/severity="(\w+)"/)[1];
                const message = error.match(/message="([^"]+)"/)[1];
                const source = error.match(/source="([^"]+)"/)[1];
                const file = files[index].split('/').pop();
                
                return `${file}:${line}:${column} ${severity} ${message} (${source})`;
              });

              body += '<details>\n<summary>ESLint Results';
              if (formattedErrors.length > MAX_LINES) {
                body += ` (showing first ${MAX_LINES} of ${formattedErrors.length} issues)</summary>\n\n```\n`;
                body += formattedErrors.slice(0, MAX_LINES).join('\n');
                body += `\n\n... and ${formattedErrors.length - MAX_LINES} more issues ...`;
              } else {
                body += ` (${formattedErrors.length} issues)</summary>\n\n```\n`;
                body += formattedErrors.join('\n');
              }
              body += '\n```\n</details>\n\n';
            }
            
            if (fs.existsSync('jest-junit.xml')) {
              body += '<details>\n<summary>Test Results</summary>\n\n```\n';
              body += fs.readFileSync('jest-junit.xml', 'utf8');
              body += '\n```\n</details>\n\n';
            }
            
            const coverageDetails = fs.readFileSync('coverage/coverage-summary.json', 'utf8');
            body += '<details>\n<summary>Test Coverage Details</summary>\n\n```json\n';
            const coverage = JSON.parse(coverageDetails);
            const files = Object.keys(coverage);
            
            if (files.length > MAX_LINES) {
              const truncatedCoverage = {};
              files.slice(0, MAX_LINES).forEach(file => {
                truncatedCoverage[file] = coverage[file];
              });
              truncatedCoverage['...'] = `${files.length - MAX_LINES} more files truncated`;
              body += JSON.stringify(truncatedCoverage, null, 2);
            } else {
              body += JSON.stringify(coverage, null, 2);
            }
            body += '\n```\n</details>\n\n';
            
            body += `üïí Last updated: ${results.test.timestamp}\n`;
            body += `üîó [View Run](${results.test.run_url})`;
            
            const comments = await github.rest.issues.listComments({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo
            });
            
            const botComment = comments.data.find(comment => 
              comment.user.type === 'Bot' && 
              comment.user.login === 'github-actions[bot]' &&
              comment.body.includes('Test Results')
            );
            
            if (botComment) {
              await github.rest.issues.updateComment({
                comment_id: botComment.id,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: body
              });
            } else {
              await github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: body
              });
            }

      - name: Check Results
        if: ${{ inputs.FAIL_FAST }}
        run: |
          if [ "$TEST_STATUS" != "0" ] || [ "$LINT_STATUS" != "0" ] || (( $(echo "$COVERAGE < ${{ inputs.COVERAGE_THRESHOLD }}" | bc -l) )); then
            echo "::error::Checks failed! Cannot proceed."
            exit 1
          fi